name: CD Staging

on:
  push:
    branches: [staging]

concurrency:
  group: cd-staging-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy-staging:
    runs-on: self-hosted
    environment: staging

    env:
      REGISTRY: ghcr.io
      IMAGE_WEB: ghcr.io/jargonless-website/portfolio-web
      IMAGE_API: ghcr.io/jargonless-website/portfolio-api
      STACK_NAME: portfolio-stg
      COMPOSE_PROJECT_NAME: portfolio-stg
      WORKSPACE_ROOT: /volume1/docker/portfolio/.deploy/staging
      HOST_PROJECT_ROOT: /volume1/docker/portfolio
      HOST_ENV_FILE: /work/infra/compose/.env.production.stg
      HOST_TUNNEL_FILE: /work/infra/compose/.env.tunnel.stg
      HOST_NGINX_CONFIG: /work/infra/nginx/nginx.staging.conf
      HOST_NGINX_SNIPPETS: /work/infra/nginx/snippets
      HOST_TUNNEL_VOLUME: /volume1/docker/portfolio/cloudflared

    steps:
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.GHCR_USER }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Prepare staging workspace
        run: |
          set -euo pipefail
          mkdir -p "${WORKSPACE_ROOT}"
          if [ -d "${WORKSPACE_ROOT}/.git" ]; then
            echo "Repo exists → refresh staging branch"
            git -C "${WORKSPACE_ROOT}" fetch --all --prune
            git -C "${WORKSPACE_ROOT}" checkout staging || git -C "${WORKSPACE_ROOT}" checkout -b staging
            git -C "${WORKSPACE_ROOT}" reset --hard origin/staging
            git -C "${WORKSPACE_ROOT}" clean -fdx
          else
            echo "Fresh clone of staging branch into ${WORKSPACE_ROOT}"
            rm -rf "${WORKSPACE_ROOT:?}/"*
            git clone --branch staging https://github.com/jargonless-website/jargonless-portfolio "${WORKSPACE_ROOT}"
          fi

      - name: Copy staging configuration
        run: |
          set -euo pipefail
          [ -s "${HOST_ENV_FILE}" ] || { echo "::error::Missing ${HOST_ENV_FILE}"; exit 1; }
          [ -s "${HOST_TUNNEL_FILE}" ] || { echo "::error::Missing ${HOST_TUNNEL_FILE}"; exit 1; }
          [ -f "${HOST_NGINX_CONFIG}" ] || { echo "::error::Missing ${HOST_NGINX_CONFIG}"; exit 1; }
          mkdir -p "${WORKSPACE_ROOT}/infra/compose"
          cp "${HOST_ENV_FILE}" "${WORKSPACE_ROOT}/infra/compose/.env.production.stg"
          cp "${HOST_TUNNEL_FILE}" "${WORKSPACE_ROOT}/infra/compose/.env.tunnel.stg"
          mkdir -p "${WORKSPACE_ROOT}/infra/nginx"
          cp "${HOST_NGINX_CONFIG}" "${WORKSPACE_ROOT}/infra/nginx/nginx.staging.conf"
          if [ -d "${HOST_NGINX_SNIPPETS}" ]; then
            mkdir -p "${WORKSPACE_ROOT}/infra/nginx/snippets"
            rsync -a "${HOST_NGINX_SNIPPETS}/" "${WORKSPACE_ROOT}/infra/nginx/snippets/"
          else
            mkdir -p "${WORKSPACE_ROOT}/infra/nginx/snippets"
          fi
          mkdir -p "${HOST_TUNNEL_VOLUME}"

      - name: Inspect workspace
        run: |
          set -euo pipefail
          echo "Workspace compose dir"
          ls -al "${WORKSPACE_ROOT}/infra/compose" || true
          echo "Workspace nginx dir"
          ls -al "${WORKSPACE_ROOT}/infra/nginx" || true
          echo "Cloudflared volume dir"
          ls -al "${HOST_TUNNEL_VOLUME}" || true

      - name: Pull images (staging)
        run: |
          docker pull ${IMAGE_WEB}:staging
          docker pull ${IMAGE_API}:staging

      - name: Deploy stack (staging)
        working-directory: ${{ env.WORKSPACE_ROOT }}
        env:
          COMPOSE_PROJECT_NAME: ${{ env.COMPOSE_PROJECT_NAME }}
          STACK_NAME: ${{ env.STACK_NAME }}
          APP_ENV_FILE: ${{ env.WORKSPACE_ROOT }}/infra/compose/.env.production.stg
          TUNNEL_ENV_FILE: ${{ env.WORKSPACE_ROOT }}/infra/compose/.env.tunnel.stg
          TUNNEL_VOLUME: ${{ env.HOST_TUNNEL_VOLUME }}
        run: |
          set -euo pipefail
          [ -s "${APP_ENV_FILE}" ] || { echo "::error::Missing ${APP_ENV_FILE}"; exit 1; }
          [ -s "${TUNNEL_ENV_FILE}" ] || { echo "::error::Missing ${TUNNEL_ENV_FILE}"; exit 1; }
          token_value="$(sed -n 's/^CLOUDFLARE_TUNNEL_TOKEN=//p' "${TUNNEL_ENV_FILE}")"
          [ -n "${token_value}" ] || { echo "::error::CLOUDFLARE_TUNNEL_TOKEN empty"; exit 1; }
          export CLOUDFLARE_TUNNEL_TOKEN="${token_value}"
          docker compose \
            -f infra/compose/docker-compose.yml \
            -f infra/compose/docker-compose.stg.yml \
            --env-file "${APP_ENV_FILE}" \
            up -d --remove-orphans nginx api jl_tunnel

      - name: Show container status
        run: docker ps --format 'table {{.Names}}\t{{.Status}}' | grep -E 'portfolio-stg-(nginx|api|jl_tunnel)-1' || true

      - name: Purge Cloudflare cache (staging) – index.html + current assets
        env:
          CF_ZONE_ID: ${{ secrets.CF_STAGING_ZONE_ID }}  # same zone as staging host
          CF_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
        run: |
          set -euo pipefail
          HOST=staging.jargonless.ai
          # find the running nginx container for staging by compose labels
          CID=$(docker ps --filter 'label=com.docker.compose.service=nginx' \
                         --filter 'label=com.docker.compose.project=portfolio-stg' -q | head -n1)
          [ -n "${CID}" ] || { echo "::error::staging nginx container not found"; exit 1; }

          # extract asset URLs from the live index.html
          ASSETS=$(docker exec "${CID}" sh -lc "grep -oE '/assets/[^\" ]+\\.(js|css)' /usr/share/nginx/html/index.html | sort -u" || true)

          # build JSON payload with only environment-specific URLs
          EXTRA=$(printf '%s\n' "${ASSETS}" | sed -e "s#^#,\"https://${HOST}#")
          PAYLOAD=$(printf '{"files": ["https://%s/index.html"%s]}' "${HOST}" "${EXTRA}")

          echo "Purging: ${PAYLOAD}"
          curl -sS -X POST "https://api.cloudflare.com/client/v4/zones/${CF_ZONE_ID}/purge_cache" \
            -H "Authorization: Bearer ${CF_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data "${PAYLOAD}" | tee /dev/stderr | jq -e '.success == true' >/dev/null
